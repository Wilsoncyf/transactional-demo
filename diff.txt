diff --git a/src/main/java/com/example/transactionaldemo/controller/DemoNewTxController.java b/src/main/java/com/example/transactionaldemo/controller/DemoNewTxController.java
index e69de29..6016b28 100644
--- a/src/main/java/com/example/transactionaldemo/controller/DemoNewTxController.java
+++ b/src/main/java/com/example/transactionaldemo/controller/DemoNewTxController.java
@@ -0,0 +1,65 @@
+package com.example.transactionaldemo.controller;
+
+import com.example.transactionaldemo.service.OuterServiceNewTx;
+import lombok.RequiredArgsConstructor;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
+
+@RestController
+@RequestMapping("/newtx") // 给这个 Controller 加个前缀区分
+@RequiredArgsConstructor
+public class DemoNewTxController {
+
+    private final OuterServiceNewTx outerServiceNewTx;
+
+    // --- 场景 3: 外部 REQUIRED, 内部 REQUIRES_NEW ---
+
+    @GetMapping("/scenario3/inner_success_outer_success")
+    public String runScenario3_InnerSuccess_OuterSuccess() {
+        try {
+            outerServiceNewTx.callInnerRequiresNew_OuterRequired(false, false);
+            return "场景3 (内成功, 外成功): T1 和 T2 都独立提交。预期数据库有 Outer(before), Inner, Outer(after) 日志。";
+        } catch (Exception e) {
+            return "场景3 (内成功, 外成功) 发生意外错误: " + e.getMessage();
+        }
+    }
+
+    @GetMapping("/scenario3/inner_fail_outer_success")
+    public String runScenario3_InnerFail_OuterSuccess() {
+         // 注意：在 OuterServiceNewTx 中，我们没有重新抛出内部异常
+         // 所以外部事务 T1 不会因此失败
+        try {
+             outerServiceNewTx.callInnerRequiresNew_OuterRequired(true, false);
+             return "场景3 (内失败, 外成功): T2 回滚, T1 提交。预期数据库只有 Outer(before) 和 Outer(after) 日志。";
+        } catch (Exception e) {
+             // 如果 OuterServiceNewTx 修改为重新抛出内部异常，则会进入这里
+             return "场景3 (内失败, 外成功) 发生意外错误（可能外部事务也回滚了）: " + e.getMessage();
+        }
+    }
+
+    @GetMapping("/scenario3/inner_success_outer_fail")
+    public String runScenario3_InnerSuccess_OuterFail() {
+        try {
+            outerServiceNewTx.callInnerRequiresNew_OuterRequired(false, true);
+             // 因为外部 T1 失败并抛异常，会进入下面的 catch
+            return "场景3 (内成功, 外失败) 执行完成，但似乎外部未回滚？";
+        } catch (RuntimeException e) {
+            return "场景3 (内成功, 外失败): T2 已提交, T1 回滚。预期数据库只有 Inner 日志。异常: " + e.getMessage();
+        }
+    }
+
+    // --- 场景 4: 外部无事务, 内部 REQUIRES_NEW ---
+
+    @GetMapping("/scenario4/inner_success")
+    public String runScenario4_InnerSuccess() {
+        outerServiceNewTx.callInnerRequiresNew_OuterNonTransactional(false);
+        return "场景4 (内成功): T2 提交。预期数据库只有 Inner 日志。";
+    }
+
+    @GetMapping("/scenario4/inner_fail")
+    public String runScenario4_InnerFail() {
+        outerServiceNewTx.callInnerRequiresNew_OuterNonTransactional(true);
+        return "场景4 (内失败): T2 回滚。预期数据库无新增日志。";
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/example/transactionaldemo/service/DemoSupportsController.java b/src/main/java/com/example/transactionaldemo/service/DemoSupportsController.java
index e69de29..b9f551c 100644
--- a/src/main/java/com/example/transactionaldemo/service/DemoSupportsController.java
+++ b/src/main/java/com/example/transactionaldemo/service/DemoSupportsController.java
@@ -0,0 +1,51 @@
+package com.example.transactionaldemo.service;
+
+import com.example.transactionaldemo.service.OuterServiceSupports;
+import lombok.RequiredArgsConstructor;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
+
+@RestController
+@RequestMapping("/supports") // 新的前缀 /supports
+@RequiredArgsConstructor
+public class DemoSupportsController {
+
+    private final OuterServiceSupports outerServiceSupports;
+
+    // --- 场景 5: 外部 REQUIRED, 内部 SUPPORTS ---
+
+    @GetMapping("/scenario5/inner_success")
+    public String runScenario5_InnerSuccess() {
+        try {
+            outerServiceSupports.callInnerSupports_OuterRequired(false);
+            return "场景5 (内成功): Inner 加入 Outer 的事务 T1，T1 提交。预期 DB 有 Outer(before), Inner, Outer(after)。";
+        } catch (Exception e) {
+            return "场景5 (内成功) 发生意外错误: " + e.getMessage();
+        }
+    }
+
+    @GetMapping("/scenario5/inner_fail")
+    public String runScenario5_InnerFail() {
+        try {
+            outerServiceSupports.callInnerSupports_OuterRequired(true);
+            return "场景5 (内失败) 执行完成，但似乎未回滚？"; // 正常不会到这里
+        } catch (RuntimeException e) {
+            return "场景5 (内失败): Inner 加入 T1 并失败，导致 T1 回滚。预期 DB 无新增记录。异常: " + e.getMessage();
+        }
+    }
+
+    // --- 场景 6: 外部无事务, 内部 SUPPORTS ---
+
+    @GetMapping("/scenario6/inner_success")
+    public String runScenario6_InnerSuccess() {
+        outerServiceSupports.callInnerSupports_OuterNonTransactional(false);
+        return "场景6 (内成功): Inner 以非事务方式执行，日志可能已自动提交。预期 DB 只有 Inner 日志。";
+    }
+
+    @GetMapping("/scenario6/inner_fail")
+    public String runScenario6_InnerFail() {
+        outerServiceSupports.callInnerSupports_OuterNonTransactional(true);
+        return "场景6 (内失败): Inner 以非事务方式执行，在失败前回滚了日志，但因无事务，该日志 *无法* 被回滚！预期 DB 仍然 *有* Inner 日志。";
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/example/transactionaldemo/service/InnerServiceNewTx.java b/src/main/java/com/example/transactionaldemo/service/InnerServiceNewTx.java
index e69de29..179c0e3 100644
--- a/src/main/java/com/example/transactionaldemo/service/InnerServiceNewTx.java
+++ b/src/main/java/com/example/transactionaldemo/service/InnerServiceNewTx.java
@@ -0,0 +1,32 @@
+package com.example.transactionaldemo.service;
+
+import com.example.transactionaldemo.entity.LogEntry;
+import com.example.transactionaldemo.repository.LogRepository;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.stereotype.Service;
+import org.springframework.transaction.annotation.Propagation;
+import org.springframework.transaction.annotation.Transactional;
+
+@Service
+@Slf4j
+@RequiredArgsConstructor
+public class InnerServiceNewTx {
+
+    private final LogRepository logRepository;
+
+    // 明确指定 Propagation.REQUIRES_NEW
+    @Transactional(propagation = Propagation.REQUIRES_NEW)
+    public void requiresNewAction(String message, boolean shouldFail) {
+        log.info("  [InnerServiceNewTx.requiresNewAction] 开始执行 ( REQUIRES_NEW )...");
+        logRepository.save(new LogEntry("InnerNewTx Log: " + message));
+        log.info("  [InnerServiceNewTx.requiresNewAction] 内部日志已保存 (新事务).");
+
+        if (shouldFail) {
+            log.warn("  [InnerServiceNewTx.requiresNewAction] 即将抛出运行时异常 (新事务)!");
+            throw new RuntimeException("InnerServiceNewTx 失败了!"); // 这将导致这个新事务 T2 回滚
+        }
+        log.info("  [InnerServiceNewTx.requiresNewAction] 执行完毕 (新事务).");
+        // 如果正常结束，这个新事务 T2 会在这里提交
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/example/transactionaldemo/service/InnerServiceSupports.java b/src/main/java/com/example/transactionaldemo/service/InnerServiceSupports.java
index e69de29..33df09d 100644
--- a/src/main/java/com/example/transactionaldemo/service/InnerServiceSupports.java
+++ b/src/main/java/com/example/transactionaldemo/service/InnerServiceSupports.java
@@ -0,0 +1,38 @@
+package com.example.transactionaldemo.service;
+
+import com.example.transactionaldemo.entity.LogEntry;
+import com.example.transactionaldemo.repository.LogRepository;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.stereotype.Service;
+import org.springframework.transaction.annotation.Propagation;
+import org.springframework.transaction.annotation.Transactional;
+import org.springframework.transaction.support.TransactionSynchronizationManager; // 用于检查当前是否存在事务
+
+@Service
+@Slf4j
+@RequiredArgsConstructor
+public class InnerServiceSupports {
+
+    private final LogRepository logRepository;
+
+    // 明确指定 Propagation.SUPPORTS
+    @Transactional(propagation = Propagation.SUPPORTS)
+    public void supportsAction(String message, boolean shouldFail) {
+        // 检查当前是否存在活动的事务
+        boolean actualTransactionActive = TransactionSynchronizationManager.isActualTransactionActive();
+        log.info("  [InnerServiceSupports.supportsAction] 开始执行 ( SUPPORTS ). 当前是否存在事务? {}", actualTransactionActive);
+
+        logRepository.save(new LogEntry("InnerSupports Log: " + message));
+        log.info("  [InnerServiceSupports.supportsAction] 内部日志已保存.");
+
+        if (shouldFail) {
+            log.warn("  [InnerServiceSupports.supportsAction] 即将抛出运行时异常!");
+            throw new RuntimeException("InnerServiceSupports 失败了!");
+            // 如果当前有事务 (actualTransactionActive=true)，这个异常会导致该事务回滚
+            // 如果当前没有事务 (actualTransactionActive=false)，这个异常不会导致任何事务回滚（因为没有事务）
+            // 但已经保存的 "InnerSupports Log" 在非事务模式下可能已提交，无法回滚！
+        }
+        log.info("  [InnerServiceSupports.supportsAction] 执行完毕.");
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/example/transactionaldemo/service/OuterServiceNewTx.java b/src/main/java/com/example/transactionaldemo/service/OuterServiceNewTx.java
index e69de29..2320798 100644
--- a/src/main/java/com/example/transactionaldemo/service/OuterServiceNewTx.java
+++ b/src/main/java/com/example/transactionaldemo/service/OuterServiceNewTx.java
@@ -0,0 +1,68 @@
+package com.example.transactionaldemo.service;
+
+import com.example.transactionaldemo.entity.LogEntry;
+import com.example.transactionaldemo.repository.LogRepository;
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.stereotype.Service;
+import org.springframework.transaction.annotation.Propagation;
+import org.springframework.transaction.annotation.Transactional;
+
+@Service
+@Slf4j
+@RequiredArgsConstructor
+public class OuterServiceNewTx {
+
+    private final LogRepository logRepository;
+    private final InnerServiceNewTx innerServiceNewTx; // 注入新的 Inner Service
+
+    // === 场景 3: 外部 REQUIRED, 内部 REQUIRES_NEW ===
+    @Transactional // 默认 REQUIRED, 启动事务 T1
+    public void callInnerRequiresNew_OuterRequired(boolean innerShouldFail, boolean outerShouldFailAfter) {
+        log.info("[OuterServiceNewTx.Scenario3] 开始执行 (外部 REQUIRED)...");
+        logRepository.save(new LogEntry("OuterNewTx Log before calling inner"));
+        log.info("[OuterServiceNewTx.Scenario3] 外部日志 (before) 已保存 (事务 T1).");
+
+        try {
+            // 调用 InnerServiceNewTx 的 requiresNewAction 方法
+            // 当前事务 T1 会被挂起，innerServiceNewTx 会启动一个全新的独立事务 T2
+            innerServiceNewTx.requiresNewAction("Data from OuterNewTx", innerShouldFail);
+            // 当 requiresNewAction 执行完毕后，T2 会独立提交或回滚，然后 T1 恢复
+            log.info("[OuterServiceNewTx.Scenario3] InnerServiceNewTx 调用完毕，外部事务 T1 已恢复.");
+        } catch (RuntimeException e) {
+            // 这个 catch 块只会捕获到 InnerServiceNewTx 抛出的异常
+            // 但 T2 的回滚已经在其内部处理了
+            log.error("[OuterServiceNewTx.Scenario3] 捕获到来自 InnerServiceNewTx 的异常: {}", e.getMessage());
+            // 注意：即使捕获了内部异常，如果希望外部事务T1也因此失败，需要重新抛出
+            // throw e; // 如果希望外部也失败，取消此行注释
+        }
+
+        // T1 恢复后继续执行
+        if (outerShouldFailAfter) {
+            log.warn("[OuterServiceNewTx.Scenario3] 外部事务 T1 即将抛出异常!");
+            throw new RuntimeException("OuterServiceNewTx 在内部调用后失败了!"); // 这将导致 T1 回滚
+        }
+
+        logRepository.save(new LogEntry("OuterNewTx Log after calling inner"));
+        log.info("[OuterServiceNewTx.Scenario3] 外部日志 (after) 已保存 (事务 T1).");
+        log.info("[OuterServiceNewTx.Scenario3] 执行完毕 (外部 REQUIRED).");
+        // 如果 T1 正常结束，它会在这里提交
+    }
+
+
+    // === 场景 4: 外部无事务, 内部 REQUIRES_NEW ===
+    // 这个方法 *没有* @Transactional 注解
+    public void callInnerRequiresNew_OuterNonTransactional(boolean innerShouldFail) {
+        log.info("[OuterServiceNewTx.Scenario4] 开始执行 (外部无事务)...");
+        try {
+            // 调用 InnerServiceNewTx 的 requiresNewAction 方法
+            // 因为当前没有外部事务，innerServiceNewTx 会简单地创建一个新事务 T2
+            innerServiceNewTx.requiresNewAction("Data from Non-Transactional OuterNewTx", innerShouldFail);
+            // 如果 innerServiceNewTx 成功，T2 在其执行完毕后提交
+        } catch (RuntimeException e) {
+            // 如果 innerServiceNewTx 失败，T2 会回滚
+            log.error("[OuterServiceNewTx.Scenario4] 捕获到来自 InnerServiceNewTx 的异常: {}", e.getMessage());
+        }
+        log.info("[OuterServiceNewTx.Scenario4] 执行完毕 (外部无事务).");
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/example/transactionaldemo/service/OuterServiceSupports.java b/src/main/java/com/example/transactionaldemo/service/OuterServiceSupports.java
index e69de29..3a519a6 100644
--- a/src/main/java/com/example/transactionaldemo/service/OuterServiceSupports.java
+++ b/src/main/java/com/example/transactionaldemo/service/OuterServiceSupports.java
@@ -0,0 +1,58 @@
+package com.example.transactionaldemo.service;
+
+import com.example.transactionaldemo.entity.LogEntry;
+import com.example.transactionaldemo.repository.LogRepository;
+import com.example.transactionaldemo.service.InnerServiceSupports; // 注入 Supports Service
+import lombok.RequiredArgsConstructor;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.stereotype.Service;
+import org.springframework.transaction.annotation.Transactional;
+
+@Service
+@Slf4j
+@RequiredArgsConstructor
+public class OuterServiceSupports {
+
+    private final LogRepository logRepository;
+    private final InnerServiceSupports innerServiceSupports; // 注入 Supports Service
+
+    // === 场景 5: 外部 REQUIRED, 内部 SUPPORTS ===
+    @Transactional // 默认 REQUIRED, 启动事务 T1
+    public void callInnerSupports_OuterRequired(boolean innerShouldFail) {
+        log.info("[OuterServiceSupports.Scenario5] 开始执行 (外部 REQUIRED)...");
+        logRepository.save(new LogEntry("OuterSupports Log before calling inner"));
+        log.info("[OuterServiceSupports.Scenario5] 外部日志 (before) 已保存 (事务 T1).");
+
+        try {
+            // 调用 InnerServiceSupports 的 supportsAction 方法
+            // 因为当前方法有事务 T1，InnerServiceSupports 的方法会加入这个事务 T1
+            innerServiceSupports.supportsAction("Data from OuterSupports", innerShouldFail);
+        } catch (RuntimeException e) {
+            log.error("[OuterServiceSupports.Scenario5] 捕获到来自 InnerServiceSupports 的异常: {}", e.getMessage());
+            // 因为 inner 加入了 T1，它的失败会导致 T1 回滚，所以这里需要重新抛出异常
+            throw e;
+        }
+
+        // 这段代码只有在 innerServiceSupports.supportsAction 没有抛异常时才会执行
+        logRepository.save(new LogEntry("OuterSupports Log after calling inner"));
+        log.info("[OuterServiceSupports.Scenario5] 外部日志 (after) 已保存 (事务 T1).");
+        log.info("[OuterServiceSupports.Scenario5] 执行完毕 (外部 REQUIRED).");
+        // 如果 T1 正常结束，它会在这里提交
+    }
+
+    // === 场景 6: 外部无事务, 内部 SUPPORTS ===
+    // 这个方法 *没有* @Transactional 注解
+    public void callInnerSupports_OuterNonTransactional(boolean innerShouldFail) {
+        log.info("[OuterServiceSupports.Scenario6] 开始执行 (外部无事务)...");
+        try {
+            // 调用 InnerServiceSupports 的 supportsAction 方法
+            // 因为当前方法没有事务，InnerServiceSupports 的方法会以非事务方式执行
+            innerServiceSupports.supportsAction("Data from Non-Transactional OuterSupports", innerShouldFail);
+        } catch (RuntimeException e) {
+            // 这个 catch 只会捕获异常，因为没有事务，所以没有事务回滚发生
+            log.error("[OuterServiceSupports.Scenario6] 捕获到来自 InnerServiceSupports 的异常: {}", e.getMessage());
+            log.warn("[OuterServiceSupports.Scenario6] 注意：如果内部方法在抛异常前保存了数据，该数据可能已提交且无法回滚！");
+        }
+        log.info("[OuterServiceSupports.Scenario6] 执行完毕 (外部无事务).");
+    }
+}
\ No newline at end of file
